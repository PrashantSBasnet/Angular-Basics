module.ts
app.module.ts
index.html <app-route> loads app.component.ts
app.component.ts -- html, css and all..


Components
app.component is on top of other components. add other components on it


components
	- used to build web pages (UI)
	- empty typescript class (eg AppComponent {} ) and we transfer it into something else by add a decorator @NgModule({})
	


module
	to bundle different pieces/functionality of app (eg.components of app) into packages
	empty typescript class (eg AppModule {} ) and we transfer it into something else by add a decorator @NgModule({})


why we import typescript classes (like server.component) without .ts extension?
-because the extension is added by webpack which bundles our project automatically
-angular when runs will know that server.component.ts is a part of the app


what do imports do?
- allow us to add other modules in a module
- angular itself is split into modules (BrowserModule, FormsModule, etc.)


selecting by class is also supported by angular
e.g 
	selector: '.app-servers'
	in html file  <div class= "app-servers">...</div>

constructor()
	method executable at the point of time the component is created by angular


Data Binding
String interpolation {{ data }}  --data can be in the form of number or other formats which can be converted easily into String
Property binding [property]="data"
Event Binding (event) ="expression"
Two-way-binding [(ngModel)]="data"


Directives 
	instruction in the DOM
	e.g using selector to use components

Structural directive
*ngIf
	* is required 
	structural directive because it changes the structure of our DOM (it either adds the element or doesn't)

using ngStyle

*ngFor 
	let i = index (index gives access to the 

Attribute directives

Models
	typescript file
	typescript is not supported by browser. it is converted into javascript to be runnable

Feature of typescript:

	The constructor automatically creates name  and amount attributes because of the use of accessmodifier public. 
	if public is not used it acts as a typical constructor that requires attributes to be defined.
	export class Ingredient{
  		constructor(public name: string, public amount:number){}
	}
	

Component and Databinding
	Property and Event Binding
	Binding to Custom Properties
		(default) all properties of components are only accessible inside that component
		@Input() decorator solves this problem by exposing it to other components
		@Input()  element: { type: string; name: string; content: string; } | any; 
		assigning alias e.g @Input('sample')... now alias name ('sample') should be used in other components to pass data
		
		@Input - from parent to child component
		@Output() - from child to parent component/ to make a property listenable from outside i.e. parent component e.g. emit

Cross Component Communication
	Approach 1: using @Input and @Output (Binding to Custom Properties)
	Approach 2: 


Event Capsulation 


View Capsulation
	shadow DOM supported by certain browsers
	@Component {(encapsulation: ViewEncapsulation.None)} makes the style global e.g. changing css style in one component overrides the style in all components.


Local Reference in Templates
	input type="text" class="form-control"
    	#severNameInput> <!-- use of local reference instead of two way binding -> [(ngModel)]="newServerName"> -->
	

Projecting Content Into Components with ng-content
	-(default angular behaviour) every HTML between opening and closing <app-server-element>....</app-server-element> is lost 
	-put <ng-content></ng-content> where it is to be displayed	
	-can be used for navigation for simple apps


LifeCycle of Component
	ngOnChanges		Starts when new component is created. Also called after a bound input property changes (when property receives new values)
	ngOnInit		Called once the component is initialized. Component is not added to DOM yet so invisible. 
	ngDoCheck 		Called during every change detection run (e.g when property changes) executed on every check. (e.g for every triggering events, timer)
	ngAfterContentInit 	Called after content (ng-content) has been projected into view
	ngAfterContentChecked	Called every time the projected content has been checked
	ngAfterViewInit 	Called after the component's view (and child views) has been initialized
	ngAfterViewChecked 	Called every time the view (and child's views) have been checked
	ngOnDestroy		Called once the component is about to be distroyed

	
Directives
	Attribute Directives    only affect/change the element they are added to (eg. changes bg color) [ngClass] [ngStyle]
	angular can render templates without DOM (while service use cases..)
	create custom attribute directives
	use of Decorator @HostListener, @HostBinding 

	*Structural Directives  affect a whole area in the DOM (elements get added/removed) eg. *ngIf *ngFor
	

Services
	a normal typescript class. no need to add @Service
	class that acts as a central repository(business unit) where you can centralize your business logic
	
	Dependency Injection
	-angular creates instances of services when it comes across selectors
	-Hiearchial injector 
		AppModule 	(if we provide a service in AppModule, the same instance of the class of the service is available in whole app/component/directive
		AppCompoent 	(same instace of service is available for all Components (but not for other services)) app component and its children
	Any other compononent 	(same instance of service is available for the Components and all its child components) 
	Single component with no child components - instances can be ovveriden in the parent 

	@Injectibe() -- used in the service where sth is expected to be injected
	export class AccountsServce {}

	
	





